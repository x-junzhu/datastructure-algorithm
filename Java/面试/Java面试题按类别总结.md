# Java面试题按类别总结(2020.10.07)
## 1、Java基础
> 1.1 equals和==区别(null哪个能用), 如果没有重写equals方法,那么a==b和a.equals(b)一样吗(2020字节提前批)

equals(): 方法
1. 是一个方法，而非运算符
2. 只能适用于引用数据类型
3. Object类中equals()的定义：
    public boolean equals(Object obj) {
	        return (this == obj);
	  }
* 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体

4. 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的"实体内容"是否相同。  
5. 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么，我们就需要对Object类中的equals()进行重写.重写的原则：比较两个对象的实体内容是否相同.

== ：运算符
1. 可以使用在基本数据类型变量和引用数据类型变量中
2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）
+ 如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体
+ 补充： == 符号使用时，必须保证符号左右两边的变量类型一致。

所以, ==可以判断对象为null, equals()不能, 如果该类没有重写equals方法, 则使用Object类的equals的方法, 而Object中的equals使用就是==判断

> 1.2 hashcode和equals(2020字节提前批)<br>

> 1.3 创建线程的方法及区别(2020字节提前批)

方式一：继承Thread类的方式

方式二：实现Runnable接口的方式

方式三：实现Callable接口。 --- JDK 5.0新增

如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
1. call()可以返回值的。
2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
3. Callable是支持泛型的

方式四：使用线程池

好处：
1.提高响应速度（减少了创建新线程的时间）
2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）
3.便于线程管理
      corePoolSize：核心池的大小
      maximumPoolSize：最大线程数
      keepAliveTime：线程没任务时最多保持多长时间后会终止

> 1.4 try catch能捕获到哪些异常(2020字节提前批)

异常分类(广义的异常包括错误)
```java
java.lang.Throwable
  |-----java.lang.Error:一般不编写针对性的代码进行处理。
  |-----java.lang.Exception:可以进行异常的处理
      |------编译时异常(checked)
        |-----IOException
        |-----FileNotFoundException
        |-----ClassNotFoundException
      |------运行时异常(unchecked,RuntimeException)
        |-----NullPointerException
        |-----ArrayIndexOutOfBoundsException
        |-----ClassCastException
        |-----NumberFormatException
        |-----InputMismatchException
        |-----ArithmeticException
```
try catch能捕获到java.lang.Exception

> 1.5 重载和重写的区别(2020招银网络提前批)

① 概念

重载:同一个类中,相同的方法名;不同的参数列表,包括不同的参数类型和不同的参数个数

重写:子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作.
重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

② 重载和重写的规则

③ 重载: 不表现为多态性<br>
重写: 表现为多态性

重载，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。
所以：对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；
而对于多态，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。

> 1.6 static和final会被重写吗(2020招银网络提前批)

static和final都不能被重写, 静态方法在编译期就被确定了, 所以不能被重写.

***final***
1. final 用来修饰一个类:此类不能被其他类所继承。比如：String类、System类、StringBuffer类<br>
2. final 用来修饰方法：表明此方法不可以被重写比如：Object类中getClass()<br>
3. final 用来修饰变量：此时的"变量"就称为是一个常量<br>
4. final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化
5. final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。       
> static final 用来修饰属性：全局常量<br>

***static***

static修饰属性：静态变量（或类变量）

1. 属性，是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)
2. 实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。
静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。
3. static修饰属性的其他说明：
    ① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用
 ② 静态变量的加载要早于对象的创建。
 ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。

|  |类变量|实例变量|
|:----:|:----:|:----:|
|类|yes|no|
|对象|yes|yes|
static修饰方法：静态方法、类方法
1. 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

2.
|  |静态方法|非静态方法|
|:----:|:----:|:----:|
|类|yes|no|
|对象|yes|yes|

3. 静态方法中，只能调用静态的方法或属性非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性
4. 静态属性举例：System.out; Math.PI;

> 1.7 string三姐妹(2020招银网络提前批)

String(JDK1.0)不可变的字符序列; 底层使用final char[]存储

StringBuffer(JDK1.0)可变的字符序列;线程安全的, 效率低; 底层使用transient char[]存储

StringBuilder(JDK1.5)可变的字符序列；jdk5.0新增的，线程不安全的，效率高；底层使用char[]存储

***String:字符串, 使用一对""引起来表示***

1. String声明为final的，不可被继承
2. String实现了Serializable接口：表示字符串是支持序列化的。实现了Comparable接口：表示String可以比较大小
3. String内部定义了final char[] value用于存储字符串数据
4. 通过字面量的方式（区别于new给一个字符串赋值，此时的字符串值声明在字符串常量池中)
5. 字符串常量池中是不会存储相同内容(使用String类的equals()比较，返回true)的字符串的

***不可变性的说明***

1. 当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值。
2. 当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。
3. 当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的value进行赋值。

关于可变性的扩容问题
扩容问题:如果要添加的数据底层数组装不下了，那就需要扩容底层的数组。默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。


> 1.8 逻辑与的短路原则, &&如果前面为false，后面如果有空指针语句，会不会报异常(2020招银网络提前批)

逻辑与短路原则: 执行逻辑判断时能够判断整条语句的正确了那就不执行后面的语句了
* 例: A || B 如果A是true则B不会执行

会报NullPointerException

> 1.9 类的生命周期(2020招银网络提前批)

> 1.10 说说你理解的反射，应用在哪(可以往Spring框架上说)(2020招银网络提前批)

Reflection（反射)是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何
类的内部信息，并能直接操作任意对象的内部属性及方法。

> 1.11 arraylist，linkedlist，hashset区别和使用场景，线程安全(2020京东提前批)

ArrayList、LinkedList、Vector三者的异同点(后面再补充一下HashSet)

同: 三者都是实现了List接口，存储数据的特点的相同：存储有序的、可重复的数据<br>
不同:<br>
 ArrayList:是List的主要实现类，线程不安全、效率高；底层使用Object[] elementData存储.<br>
 源码分析(jdk1.8):ArrayList list = new ArrayList()初始化时(没有添加元素之前)底层是只是新建一个空的Object[]对象数组,当开始add数据的时候,则见一个长度为10的默认Object[]对象数组,用来保存数据,当添加到超过数据长度是,开始扩容, 默认情况是扩容为当前数组长度的1.5倍,同时将原来数组中的数据复制到当前数组.
 而(jdk1.7)在初始化时候就建立默认长度的Object[]对象数组,其他的过程和jdk1.8一样.

 LinkedList: 对于频繁的插入和删除操作，使用此类效率比ArrayList高；底层使用双向列表存储.<br>
 源码分析(jdk1.8):LinkedList list = new LinkedList()初始化时,在内部声明了一个内部类Node节点,维护的是一个双链表结构,每一次add操作都是将该对象封装到Node节点中.

 Vecetor:作为List接口的古老实现类；线程安全、效率低；底层使用Object[] elementData存储.<br>
 源码分析:jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组在扩容方面，默认扩容为原来的数组长度的2倍。

> 1.12 new子类的时候，子类和父类静态代码块，构造器的执行顺序(2020京东提前批)

由父及子，静态先行

静态代码块：

* 内部可以输出语句
* 随着类的加载而执行,而且只执行一次
* 作用：初始化类的信息
* 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行
* 静态代码块的执行要优先于非静态代码块的执行
* 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构

非静态代码块：

* 内部可以输出语句
* 随着对象的创建而执行
* 每创建一个对象，就执行一次非静态代码块
* 作用：可以在创建对象时，对对象的属性等进行初始化
* 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行
* 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法

> 1.13 runnable和callable区别(2020京东提前批)

如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？
1. call()可以返回值的。
2. call()可以抛出异常，被外面的操作捕获，获取异常的信息
3. Callable是支持泛型的

> 1.14 用过序列化和反序列化吗(2020京东提前批)

> 1.15 内存泄露的场景(2020招行总行提前批)

内存泄漏就是有大量的引用指向某些对象, 但是这些对象以后不会使用了, 但是因为它们还和GC ROOT有关联, 所以导致以后这些对象也不会被回收, 这就是内存泄漏的问题.

**方法区主要存放的是类及类信息, 而堆中主要存放的是实例化的对象**

内存泄漏场景:
* 加载大量的第三方的jar包
* Tomcat部署的工程过多
* 大量动态的生成反射类

> 1.16 说一下hashmap实现, 线程安全的hashmap(2020新浪微博提前批)<br>

```
从JDK 1.7开始说起:
HashMap map = new HashMap()开始在底层创建一个长度为16的Entry[] 数组.在此之前已经
put(key, value)多次,知道本次map.put(key1, value1),首先通过可以所在类的hashCode()计算器哈希值，
即该条数据在Entry[]数组中位置：
  如果该哈希值对应Entry[]数组的位置为空，则插入成功 --> 情况1
  如果该哈希值对应Entry[]数组的位置不为空(可能存在一条数据或者一个链表),开始对比
  (key1, value1)的哈希值与该位置上所有元素的哈希值:
      如果(key1, value1)与该位置上所有元素的哈希值均不相同，则插入成功 --> 情况2
      如果(key1, value1)与该位置上的某条数据(key2, value2)的哈希值相等，则开始比较key1.value.equals(key2.value):
          如果equals返回false，则添加成功 --> 情况3
          如果equals返回true,则用value2替换value1
说明: 情况2和情况3(key1, value1)都是采用链表方式存储.
补充JDK 1.8:
1.new HashMap()的时候不会一开始就创建一个长度为16的数组，只有在第一次put()操作后，才创建数组。
2.JDK 1.8底层使用的数组是Node[],而非Entry[]
3.JDK 1.7底层使用的是数组+链表, JDK 1.8使用的是数组+链表+红黑树
4.JDK 1.7的链表采用的是头插法，JDK 1.8的链表采用的是尾插法。
5.JDK 1.8中当链表长度大于8，并且Node[]数组长度大于64时，链表转换成红黑树。
在不断添加的过程中会涉及到扩容问题，当数组中位置使用超过临界值且下一个存储的位置不空的时候，
将数组长度扩容为原来的两倍，并且把原数组复制到新的数组中。
HashMap底层典型属性的属性的说明：
DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64
```

> 1.17 String类型底层原理说一下; 如果String里有多个key-value, 那怎么存储(2020OPPO提前批一面)

> 1.18 前缀树了解吗, 说一下结构(2020OPPO提前批一面)

> 1.19 调用start和run的区别? sleep和wait区别(2020美团点评)

## 2、JVM
> 2.1 类加载过程和双亲委派机制(2020字节提前批)

类加载过程: 加载(loading)=>链接(验证->准备->解析)=>初始化

![avatar](image/classloader.png)

***加载阶段***
1. 通过一个类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

***链接阶段***
1. 验证
* 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求, 保证被加载类的正确性, 不会危害虚拟机自身安全
* 主要包括四种验证: 文件格式验证, 元数据验证, 字节码验证, 符号引用验证
> 使用BinaryViewer查看字节码文件，其开头均为 CAFE BABE ，如果出现不合法的字节码文件，那么将会验证不通过

2. 准备
* 为类变量分配内存并且设置类变量的默认初始值, 即零值
* 这里不包含用final修饰的static, 因为final在编译的时候就会分配了, 准备阶段会显示初始化.
* 这里不会为实例变量分配初始化, 类变量会分配在方法区中, 而实例变量会随着对象一起分配到Java堆中。
3. 解析
* 将常量池内的符号引用转换为直接引用的过程.
* 事实上, 解析操作往往会伴随着JVM在执行完初始化之后再执行.
* 符号引用就是一组符号来描述所以引用的目标。符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。直接引用就是直接指向目标的指针、相对偏移或一个间接定位到目标的句柄。
* 解析的主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等

***初始化阶段***

1. 初始化阶段就是执行类构造器方法\<clinit>()的过程
2. 此方法不需定义，是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。也就是说，当我们代码中包含**static变量或者静态代码块**的时候，就会有\<clinit>()方法
3. \<clinit>()方法中的指令按语句在源文件中出现的顺序执行
4. \<clinit>()不同于类的构造器(关联：构造器是虚拟机视角下的\<init>())
5. 若该类具有父类，JVM会保证子类的\<clinit>()执行前，父类的\<clinit>()已经执行完毕
6. 虚拟机必须保证一个类的\<clinit>()方法在多线程下被同步加锁,即：一个类只会被类的加载器加载一次

***双亲委派机制***

Java虚拟机对class文件采用的是按需加载的方式, 也就是说当需要使用该类时才会将它的class文件加载到内存生成class对象。而且加载某个类的class文件时，Java虚拟机采用的是双亲委派模式，即把请求交由父类处理，它是一种任务委派模式。

类加载器分类
1. 启动类加载器（引导类加载器，Bootstrap ClassLoader）
* 这个类加载使用C/C++语言实现的，嵌套在JVM内部。
* 它用来加载Java的核心库（JAVAHOME/jre/1ib/rt.jar、resources.jar或sun.boot.class.path路径下的内容），用于提供JVM自身需要的类。
* 并不继承自ava.lang.ClassLoader，没有父加载器。
* 加载扩展类和应用程序类加载器，并指定为他们的父类加载器。
* 出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类

2. 扩展类加载器（Extension ClassLoader）
* Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。
* 派生于ClassLoader类
* 父类加载器为启动类加载器
* 从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/1ib/ext子目录（扩展目录）下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

3. 应用程序类加载器（系统类加载器，AppClassLoader）
* java语言编写，由sun.misc.LaunchersAppClassLoader实现
* 派生于ClassLoader类
* 父类加载器为启动类加载器
* 它负责加载环境变量classpath或系统属性java.class.path指定路径下的类库
* 该类加载是程序中默认的类加载器，一般来说，Java应用的类都是由它来完成加载
* 通过classLoader#getSystemclassLoader()方法可以获取到该类加载器

![avatar](image/classloader_classifer.png)

工作原理:

* 如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行;
* 如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器;
* 如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。

![avatar](image/loader.png)

**优点**
1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意篡改
* 自定义类：java.lang.String
* 自定义类：java.lang.ShkStart（报错：阻止创建 java.lang开头的类）

> 2.2 新生代和老年代都用什么算法(2020字节提前批)

1. 什么是垃圾: 垃圾是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾

2. 垃圾回收的几个阶段

   ① 标记阶段: 判断对象存活一般有两种方式：**引用计数算法**和**可达性分析算法**

   ② 清除阶段

3. 标记阶段

* 引用计数算法: 引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的引用计数器属性, 用于记录对象被引用的情况。

  优点：实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。

  缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销。

  > 每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了时间开销。 引用计数器有一个严重的问题，即无法处理循环引用的情况。这是一条致命缺陷，导致在Java的垃圾回收器中没有使用这类算法。

* 可达性分析算法: 也可以称为 根搜索算法、追踪性垃圾收集, 相较于引用计数算法，这里的可达性分析就是Java、C#选择的。这种类型的垃圾收集通常也叫作追踪性垃圾收集（Tracing Garbage Collection）

  **具体思路**

  所谓"GCRoots”根集合就是一组必须活跃的引用

  + 可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达
  + 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链（Reference Chain）
  + 如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象
  + 在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。

  GC Roots可以是那些？

  * 虚拟机栈中引用的对象：比如各个线程被调用的方法中使用到的参数、局部变量等
  * 本地方法栈内JNI（通常说的本地方法）引用的对象方法区中类静态属性引用的对象: 
  * 方法区中常量引用的对象
  * 所有被同步锁synchronized持有的对象
  * Java虚拟机内部的引用
  * 反映java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

4. 清除阶段

* 标记-清除算法

  当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为stop the world），然后进行两项工作，第一项则是标记，第二项则是清除

  * **标记**：Collector从引用根节点开始遍历，**标记所有被引用的对象**。一般是在对象的Header中记录为可达对象，***注：标记的是引用对象，不是垃圾！！！***
  * **清除**：Collector对堆内存从头到尾进行线性的遍历，如果发现某个对象在其Header中没有标记为可达对象，则将其回收

  什么是清除？

  这里所谓的清除并不是真的置空，而是把需要清除的对象地址保存在空闲的地址列表里。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放覆盖原有的地址

  如果内存规整：采用指针碰撞的方式进行内存分配

  如果内存不规整: 虚拟机需要维护一个列表，即空闲列表分配

* 复制算法

  核心思想：将活着的内存空间分为两块，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收

  优点：① 没有标记和清除过程，实现简单，运行高效 ②复制过去以后保证空间的连续性，不会出现“碎片”问题。

  缺点：①此算法的缺点也是很明显的，就是需要两倍的内存空间② 对于G1这种分拆成为大量region的GC，复制而不是移动，意味着GC需要维护region之间对象引用关系，不管是内存占用或者时间开销也不小

* 标记-整理算法

  第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象

  第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。之后，清理边界外所有的空间

  优点

  * 消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM只需要持有一个内存的起始地址即可。
  * 消除了复制算法当中，内存减半的高额代价

  缺点

  * 从效率上来说，标记-整理算法要低于复制算法。
  * 移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址
  * 移动过程中，需要全程暂停用户应用程序。即：STW

5. 垃圾收集思想

   5.1 分代收集算法

   分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。

   在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。

   在HotSpot中，基于分代的概念，GC所使用的内存回收算法必须结合年轻代和老年代各自的特点

   * 年轻代（Young Gen）

   年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。

   这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而复制算法内存利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。

   * 老年代（Tenured Gen）

   老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁。

   这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。

   以HotSpot中的CMS回收器为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。而对于碎片问题，CMS采用基于Mark-Compact算法的Serial old回收器作为补偿措施：当内存回收不佳（碎片导致的Concurrent Mode Failure时），将采用serial old执行FullGC以达到对老年代内存的整理。

   5.2 增量收集算法

   上述现有的算法，在垃圾回收过程中，应用软件将处于一种stop the World的状态。在stop the World状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将严重影响用户体验或者系统的稳定性。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。

   如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成。

   总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。**增量收集算法通过对线程间冲突的妥善处理**，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作

   5.3 分区收集算法

   一般来说，在相同条件下，堆空间越大，一次Gc时所需要的时间就越长，有关GC产生的停顿也越长。为了更好地控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

   分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。 每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。

> 2.3 jvm内存模型;堆的划分,垃圾回收算法(2020字节提前批)

JVM内存模型:

![avatar](image/jvm_memory_model.png)

一个进程对应一个JVM实例, 对应一个RunTime实例

RunTime Data Area

***堆:***

![avatar](image/jvm_heap.png)

堆的划分: 年轻代和老年代, 在年轻代中又可以划分为Eden和Survivor0、Survivor1区

* Eden : Survivor0 : Survivor1 = 8 : 1 : 1
* Young Gen : Old Gen = 1 : 2

**堆内的垃圾回收**

我们创建的对象, 一般都是存放在Eden区的, 当我们Eden区满了后，就会触发Minor GC(Young GC)操作

![avatar](image/jvm_MinorGc01.png)

当我们进行一次垃圾收集后，红色的(没有指针指向的对象)将会被回收, 而绿色的还会被占用着, 将绿色存放到Survivor0(From)区。同时我们给每个对象设置了一个年龄计数器, 每一次回收后就是加1

同时Eden区继续存放对象, 当Eden区再次存满的时候, 又会触发一个Minor GC操作, 此时GC将会把 Eden和 Survivor0(From)中的对象 进行一次收集, 把存活的对象放到 Survivor1(To)区, 同时把Survivor0(From)中的对象拷贝到Survivor1(To)区并让其年龄加1

![avatar](image/jvm_MinorGc02.png)

我们继续不断的进行对象生成 和 垃圾回收, 当Survivor0/1中的对象的年龄达到15的时候, 将会触发一次 Promotion晋升的操作, 也就是将年轻代中的对象 晋升到 老年代中

![avatar](image/jvm_MinorGc03.png)

思考：幸存者区满了后?

* 特别注意，在Eden区满了的时候，才会触发MinorGC，而幸存者区满了后，不会触发MinorGC操作
* 如果Survivor区满了后，将会触发一些特殊的规则，也就是可能直接晋升老年代

***对象分配的特殊情况***

![avatar](image/jvm_object_asign.png)

***方法区:***

《深入理解Java虚拟机》书中对方法区(Method Area)存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等

1. 类型信息: 对每个加载的类型（类class、接口interface、枚举enum、注解annotation），JVM必须在方法区中存储以下类型信息
* 这个类型的完整有效名称(全名=包名.类名)
* 这个类型直接父类的完整有效名(对于interface或是java.lang.object, 都没有父类)
* 这个类型的修饰符(public，abstract，final的某个子集)
* 这个类型直接接口的一个有序列表

2. 域信息: JVM必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
* 域的相关信息包括：域名称、域类型、域修饰符(public，private，protected，static，final，volatile，transient的某个子集)

3. 方法(Method)信息: JVM必须保存所有方法的以下信息, 同域信息一样包括声明顺序
* 方法名称
* 方法的返回类型（或void）
* 方法参数的数量和类型（按顺序）
* 方法的修饰符（public, private, protected, static, final, synchronized, native, abstract的一个子集）
* 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract和native方法除外）
* 异常表（abstract和native方法除外）

3. non-final的类变量

静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分

类变量被类的所有实例共享，即使没有类实例时，你也可以访问它

4. 全局常量

全局常量就是使用 static final 进行修饰

被声明为final的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。

> 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

***方法区的演进细节***

首先明确: 只有Hotspot才有永久代。BEA JRockit、IBMJ9等来说, 是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节, 不受《Java虚拟机规范》管束，并不要求统一

Hotspot中方法区的变化: 

|JDK1.6及以前|有永久代，静态变量存储在永久代上|
|:----:|:----:|
|JDK1.7|有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中|
|JDK1.8|无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中|

JDK1.6

![avatar](image/jvm_methodArea_jdk1.6.png)

JDK1.7

![avatar](image/jvm_methodArea_jdk1.7.png)

JDK1.8, 此时元空间大小只受物理内存影响

![avatar](image/jvm_methodArea_jdk1.8.png)

***为什么永久代要被元空间替代***

JRockit是和HotSpot融合后的结果，因为JRockit没有永久代，所以他们不需要配置永久代

随着Java8的到来，HotSpot VM中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个与堆不相连的本地内存区域，这个区域叫做元空间（Metaspace）

由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间，这项改动是很有必要的，原因有: 
* 为永久代设置空间大小是很难确定的

在某些场景下, 如果动态加载类过多, 容易产生Perm区的OOM。比如某个实际Web工程中, 因为功能点比较多, 在运行过程中, 要不断动态加载很多类, 经常出现致命错误。

“Exception in thread‘dubbo client x.x connector'java.lang.OutOfMemoryError:PermGen space”

而元空间和永久代之间最大的区别在于: 元空间并不在虚拟机中，而是使用本地内存。因此, 默认情况下, 元空间的大小仅受本地内存限制。

* 对永久代进行调优是很困难的, 而调优的目的主要是为了降低Full GC

有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK11时期的ZGC收集器就不支持类卸载）。一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏

***程序计数器***

记录下一个要执行的字节码指令

***虚拟机栈***

以栈帧的形式存在, 一个栈帧即程序中的一个方法, 每个栈帧主要包含4大块和一些附加信息

* 局部变量表: 存储方法中的形参和局部变量, 以Slot的形式存在, 包括8中基本数据类型和引用数据类型(类、接口、数组). 在非静态方法中, 局部变量表中索引0的位置存储的是this

* 操作数栈(表达式栈): 根据字节码指令弹出和压入操作数. 其中byte、short、char、boolean都是以int形式存储(4 byte)

* 动态链接: 指向运行时常量池的方法引用, 因为一个类运行过程中需要需多其他类, 所以JVM将所需要的的类加载的运行时常量池中, 每个方法通过一个指针指向该引用, 在需要使用的时候通过符号引用找到该类即可

* 方法返回地址: 存储调用该方法的程序计数器的值. 

***本地方法栈***

首先了解本地方法, 使用native(与abstract关键字不能同时使用)修饰调用C/C++语言的方法. 而本地方法栈就是管理本地方法的调用. 也允许实现固定或者动态可扩展其内存大小. 

> 2.4 锁升级有哪些变化(2020招银网络提前批)<br>

> 2.5 锁升级有哪些变化? 自动升级的条件是什么?还是会自璇多少次或者其等待线程超过多少就升级?(2020招银网络提前批)<br>

> 2.6 CAS怎么解决ABA问题(2020招银网络提前批)<br>

> 2.7 双亲委派模型好处(2020京东提前批)

**优点**
1. 避免类的重复加载
2. 保护程序安全，防止核心API被随意篡改
* 自定义类：java.lang.String
* 自定义类：java.lang.abc（报错：阻止创建 java.lang开头的类）

## 3、多线程与高并发
> 3.1 synchronized(作用在哪些位置)和lock的原理及区别(2020字节提前批)<br>

> 3.2 描述一下乐观锁和悲观锁及其原理;synchronized和lock是乐观还是悲观及ABA问题(2020字节提前批)<br>

> 3.3 进程线程协程区别和联系(2020招银网络提前批)<br>

> 3.4 线程池核心参数(2020招银网络提前批)<br>

> 3.5 ThreadLocal原理, 同时引出内存泄露(2020京东提前批)

> 3.6 Reentrantlock原理(2020京东提前批二面)

> 3.7 说说concurrenthashmap如何保证线程安全的; 除了concurrenthashmap还有哪些线程安全的集合(2020OPPO提前批一面)

> 3.8 CopyOnWriteArraylist原理说一下, 如何保证线程安全的(2020OPPO提前批一面)

## 4、Spring框架
> 4.1 说说依赖注入和ioc(控制反转)(2020字节提前批)<br>

> 4.2 说说aop(应用场景和注解)(Aspect Oriented Programming)(2020字节提前批)<br>

> 4.3 说一下动态代理(jdk和cglib), 同时说一下静态代理和动态代理区别(2020字节提前批)

> 4.4 SpringBoot介绍一下优点(2020阿里本地生活)

## 5、设计模式
> 5.1 单例模式(2020字节提前批)<br>

> 5.2 设计模式的七大原则(2020招银网络提前批)<br>

> 5.3 适配器模式(2020招银网络提前批)

## 6、计算机网络
> 6.1 http和https区别及https请求过程(2020字节提前批)<br>

> 6.2 说一下加密算法(2020字节提前批)<br>

> 6.2 dns解析过程(2020字节提前批)<br>

> 6.3 TCP和UDP区别, tcp拥塞控制(2020招银网络提前批)<br>

> 6.4 tcp三次握手四次挥手工作在哪一层(2020京东提前批)

> 6.5 说一下DNS域名解析是哪一层, 用的TCP还是UDP(2020OPPO提前批一面)

> 6.6 如何判断客户端和服务端已经建立链接(2020OPPO提前批一面)

> 6.7 IP数据包如何判断是tcp还是udp连接的(2020OPPO提前批一面)

> 6.8 ping是哪个协议? 说一下ping的过程(2020百度提前批二面)

> 6.9 子网掩码作用(2020网易互联网一面)

> 6.10 tcp滑动窗口的原理和作用(2020网易互联网一面)

> 6.11 说一下ssl/tls过程(2020网易互联网一面)

> 6.12 长连接说一下(2020美团点评)

## 7、计算机操作系统(Linux)
> 7.1 页面置换算法(2020字节提前批)

> 7.2 LRU缓存，让我设计LRU思路(2020字节提前批)

> 7.3 进程线程协程区别; 线程的切换和协程的切换有什么区别; 为什么协程切换开销少; 线程进程协程在并发访问变量的时候，都有什么措施(2020OPPO提前批一面)

> 7.4 进程的调度方式? Java用的哪个(2020百度提前批二面)

## 8、Mysql数据库
> 8.1 索引作用及索引的数据结构B和B+树(2020字节提前批)<br>

> 8.2 聚簇索引是什么; innodb是什么索引(2020字节提前批)<br>

> 8.3 MySQL有几种搜索引擎，区别(2020招银网络提前批)<br>

> 8.4 数据库查询比较慢, 怎么排查? (说了explain，sql语句优化，分库分表，用redis)(2020招银网络提前批)<br>

> 8.5 redis分布式锁(2020招银网络提前批)<br>

> 8.6 如何保证redis和数据库一致性?(答:延时双删)(2020京东提前批)<br>

> 8.7 解释一下幻读, 事务特性及隔离级别(2020京东提前批)<br>

> 8.8 mysql主从复制的同步方式有几种(2020招行总行提前批)<br>

> 8.9 char和varchar区别(2020招行总行提前批)<br>

> 8.10 Innodb引擎的特点(2020新浪微博提前批)

> 8.11 用到了哪些redis的数据结构(2020OPPO提前批一面)

> 8.11 如果优化查询(2020百度提前批二面)

> 8.12 数据库事务隔离级别, 分别产生什么问题(2020网易互联网二面)

> 8.13 聚簇索引和非聚簇索引如何加锁(2020快手提前批)

> 8.14 redis的value支持多大; redis的过期策略(2020美团点评)

## 9、手撕代码
> 9.1 生产者消费者模型(2020字节提前批)<br>

> 9.2 判断两个链表是否相交(2020字节提前批)<br>

> 9.3 判断一个链表是否有环，求出入环节点; 如果链表是有环的，那如何求两链表的相交节点<br>

> 9.4 链表反转(2020京东提前批)<br>

> 9.5 二分法找排序数组中绝对值最小的元素(2020京东提前批)

> 9.6 根据二叉树后序遍历和中序遍历输出前序遍历(2020百度提前批二面)

> 9.7 实现两种降序排序(快排, 堆排)(2020百度提前批二面)

> 9.8 两个字符串A,B，找到A中覆盖B的最短的子串(2020快手提前批)

## X、非技术类题目
> 10.1 未来3-5年之内的规划

> 10.2 如果有多个大厂offer, 会怎么选

> 10.3 如何看待35岁的事

> 10.4 为什么选择投递网易

> 10.5 期望薪资